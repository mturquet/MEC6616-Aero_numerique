#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Sep 17 17:09:31 2024

@author: mathisturquet
"""

#%% Import des librairies 

import sympy as sp
import numpy as np
import pyvista as pv
import pyvistaqt as pvQt
from meshGenerator import MeshGenerator
from meshConnectivity import MeshConnectivity
from meshPlotter import MeshPlotter
from mesh import Mesh
import matplotlib.pyplot as plt 

## test récupération nombre de faces  
mesher = MeshGenerator()
plotter = MeshPlotter()

#%% Définition des fonctions annexes 

# def normal(xa,ya,xb,yb):
#     """
#     Fonction pour renvoyer a et b du vecteur normal à une arrête tel que n = ax +by

#     Parameters
#     ----------
#     xa,ya,xb,yb Coordonnées des points A et B 

#     Returns
#     -------
#     a et b 
#     """
#     dx = xb - xa
#     dy = yb - ya
#     Delta_A = np.sqrt(dx**2 +dy**2) # Surface de la face associée
#     a = dx/Delta_A
#     b = dy/ Delta_A
#     return a,b 


def normal(xa, ya, xb, yb):
    """
    Fonction pour renvoyer a et b du vecteur normal unitaire à une arête tel que n = ax + by

    Parameters
    ----------
    xa, ya : Coordonnées du point A
    xb, yb : Coordonnées du point B

    Returns
    -------
    a, b : Composantes du vecteur normal unitaire
    """
    dx = xb - xa
    dy = yb - ya
    
    # Calcul de la longueur de l'arête (norme du vecteur)
    Delta_A = np.sqrt(dx**2 + dy**2)
    
   
    a = dy / Delta_A
    b = dx / Delta_A
    
    return a, b


def centre_element_2D(mesh_obj,i_element):
    """
    Fonction pour renvoyer  xmoy et ymoy centre des faces et lieu des éléments géométriques en 2D 

    Parameters
    ----------
    Maillage et numéro de l'élément

    Returns
    -------
    xmoy et y moy 
    """
    # Récupération des données des sommets 
    start = mesh_obj.get_element_to_nodes_start(i_element)
    fin = mesh_obj.get_element_to_nodes_start(i_element+1)
    noeuds_i_elements = mesh_obj.element_to_nodes[start:fin] # Création des listes pour les noeuds autour d'un élément
    # Calcul du centre géométrique du triangle
    xmoy = 0 # Initilaisation des coordonnées virtuelles de l'élément 
    ymoy = 0
    for i in range(len(noeuds_i_elements)):
        x,y = mesh_obj.get_node_to_xycoord(noeuds_i_elements[i])
        xmoy += x
        ymoy += y 
    xmoy = xmoy/len(noeuds_i_elements)
    ymoy = ymoy/len(noeuds_i_elements)
    return xmoy,ymoy

def phi(x,y):
    """
    Fonction pour rcrééer le champ 

    Parameters
    ----------
    coordonnées x et y 

    Returns
    -------
    Phi, le champ 
    """
    #np.sin(x)+ np.cos(y)
    return 10* np.sin(x)+ 100 *np.cos(y)


print('Rectangle : maillage non structuré avec des triangles')
mesh_parameters = {'mesh_type': 'TRI',
                   'lc': 10
                   }
mesh_obj = mesher.rectangle([0.0, 10.0, 0.0, 10.0], mesh_parameters)
conec = MeshConnectivity(mesh_obj)
conec.compute_connectivity()
#plotter.plot_mesh(mesh_obj)


def test_euler(mesh_object):
    f = mesh_obj.number_of_elements
    a =mesh_obj.number_of_faces
    s = mesh_obj.number_of_nodes
    h = 0
    if f-a+s+h ==1:
        return True 
    

   
def least_square(mesh_obj,bcdata):
    
    bc_types = [item[0] for item in bcdata]  # Extrait la première valeur de chaque tuple
    bc_numbers = [item[1] for item in bcdata]
    number_of_faces = mesh_obj.number_of_faces
    number_of_elements = mesh_obj.number_of_elements
    coordonnees_elements_x = []
    coordonnees_elements_y = []
    voisins = []
    frontiere = mesh_obj.get_number_of_boundary_faces()
    f = mesh_obj.number_of_elements
    a =mesh_obj.number_of_faces
    s = mesh_obj.number_of_nodes
    bcdata =mesh_obj.get_boundary_faces_to_tag()
    # Création de la matrice de calcul ATA 
    ATA = np.zeros((f,2,2))
    B = np.zeros((f,2))
    
    for i in range(number_of_elements):
        start = mesh_obj.get_element_to_nodes_start(i)
        fin = mesh_obj.get_element_to_nodes_start(i+1)
        noeuds_i_elements = mesh_obj.element_to_nodes[start:fin] 
        x_e, y_e = centre_element_2D(mesh_obj, i)
        coordonnees_elements_x.append(x_e)
        coordonnees_elements_y.append(y_e)  
        # Récupération des centres géométirques des éléments tri ou quad 
    
    for i in range(number_of_faces):
        neighbours_elements = mesh_obj.get_face_to_elements(i) # Récupération des éléments voisins
        voisins.append(neighbours_elements)
        Tg,Td = neighbours_elements
        # Récupération des voisins
        if neighbours_elements[1] == -1 : # pour les faces frontières 
            
            tag = mesh_obj.get_boundary_face_to_tag(i)
            bc_type = bc_types[tag]
            bc_number = bc_numbers [tag]
            
            
            
            if ( bc_type == 'DIRICHLET' ) :
                # DIRICHLET
                # Création du centre de l'arrête 
                noeuds_faces = mesh_obj.get_face_to_nodes(i)
                x_milieu = ( mesh_obj.get_node_to_xcoord(noeuds_faces[1]) + mesh_obj.get_node_to_xcoord(noeuds_faces[0]))/2
                y_milieu = ( mesh_obj.get_node_to_ycoord(noeuds_faces[1]) + mesh_obj.get_node_to_ycoord(noeuds_faces[0]))/2
                dx = (coordonnees_elements_x[neighbours_elements[0]]- x_milieu)
                dy = (coordonnees_elements_y[neighbours_elements[0]]- y_milieu)
                # Pour les arêtes internes 
                ALS = np.zeros((2,2))
                # Création des différents paramèetres de la matrice 2x2
                ALS[0,0]= dx*dx
                ALS[1,0]= dx*dy
                ALS[0,1]= dy*dx
                ALS[1,1]= dy*dy
                # Remplissage 
                ATA[Tg] += ALS
                xtg = coordonnees_elements_x[neighbours_elements[0]]
                ytg = coordonnees_elements_y[neighbours_elements[0]]
                Phi_A = phi(x_milieu,y_milieu)
                Phi_tg = phi(xtg,ytg)
                B[Tg,0] = B[Tg,0] + (x_milieu - xtg) * (Phi_A - Phi_tg)
                B[Tg,1] = B[Tg,1] + (y_milieu - ytg) * (Phi_A - Phi_tg)
                
                
            if ( bc_type == 'NEUMANN' ) :
                # Neumann
                noeuds_faces = mesh_obj.get_face_to_nodes(i)
                
                xa = mesh_obj.get_node_to_xcoord(noeuds_faces[0])
                ya = mesh_obj.get_node_to_ycoord(noeuds_faces[0])
                xb = mesh_obj.get_node_to_xcoord(noeuds_faces[1])
                yb = mesh_obj.get_node_to_xcoord(noeuds_faces[1])
                nx,ny = normal(xa,ya,xb,yb)
                xtg = coordonnees_elements_x[neighbours_elements[0]]
                ytg = coordonnees_elements_y[neighbours_elements[0]] 
                x_milieu = ( mesh_obj.get_node_to_xcoord(noeuds_faces[1]) + mesh_obj.get_node_to_xcoord(noeuds_faces[0]))/2
                y_milieu = ( mesh_obj.get_node_to_ycoord(noeuds_faces[1]) + mesh_obj.get_node_to_ycoord(noeuds_faces[0]))/2
                dx1 =((x_milieu-xtg))
                dy1 = ((y_milieu-ytg))
                dx = (dx1*nx+dy1*ny)*nx
                dy = (dx1*nx + dy1*ny)*ny
                # Matric intermédiaire
                ALS = np.zeros((2,2))
                # Création des différents paramèetres de la matrice 2x2
                ALS[0,0]= dx*dx
                ALS[1,0]= ALS[0,1]= dy*dx
                ALS[1,1]= dy*dy
                
                
                
                # Remplissage 
                ATA[Tg] += ALS
                
                xtg = coordonnees_elements_x[neighbours_elements[0]]
                ytg = coordonnees_elements_y[neighbours_elements[0]]
                dx = ((x_milieu-xtg)*nx + (y_milieu-ytg)*ny)*nx
                dy = ((x_milieu-xtg)*nx + (y_milieu-ytg)*ny)*ny
                Phi_A = bc_number # phi(x_milieu,y_milieu) # Phi milieu 
                Phi_N = bc_number
                delta_phi = ((x_milieu-xtg)*nx + (y_milieu-ytg)*ny)*Phi_N
                B[Tg,0] = B[Tg,0] + dx * delta_phi
                B[Tg,1] = B[Tg,1] + dy * delta_phi
                
                
                
            if (bc_type == 'LIBRE'):
               B[Tg,0] = B[Tg,0] 
               B[Tg,1] = B[Tg,1] 

            
        elif neighbours_elements[1] != -1 : 
            xtg = coordonnees_elements_x[neighbours_elements[0]]
            xtd =coordonnees_elements_x[neighbours_elements[1]]
            ytg = coordonnees_elements_y[neighbours_elements[0]]
            ytd = coordonnees_elements_y[neighbours_elements[1]]
            # Récupération des dx et dy pour une arrête
            dx = (coordonnees_elements_x[neighbours_elements[0]]- coordonnees_elements_x[neighbours_elements[1]])
            dy = (coordonnees_elements_y[neighbours_elements[0]]- coordonnees_elements_y[neighbours_elements[1]])
            # Pour les arêtes internes 
            ALS = np.zeros((2,2))
            # Création des différents paramèetres de la matrice 2x2
            ALS[0,0]= dx*dx
            ALS[1,0]= dx*dy
            ALS[0,1]= dy*dx
            ALS[1,1]= dy*dy
            
            ATA[Tg]+= ALS
            ATA[Td]+= ALS
            
            # Remplissage de B 
            
            Phi_td = phi(xtd,ytd)
            Phi_tg = phi(xtg,ytg)
            B[Tg,0] = B[Tg,0] + (xtd-xtg) * (Phi_td -Phi_tg)
            B[Tg,1] = B[Tg,1] + (ytd-ytg) * (Phi_td -Phi_tg)
            B[Td,0] = B[Td,0] + (xtd-xtg) * (Phi_td -Phi_tg)
            B[Td,1] = B[Td,1] + (ytd-ytg) * (Phi_td -Phi_tg)
            
    ATAI = np.zeros((f,2,2))
    for i in range(number_of_elements):
        AL = ATA[i]
        ALI = np.linalg.inv(AL)
        ATAI[i]= ALI
    Grad =np.zeros((f,2))
    for i in range(number_of_elements):
        Grad[i] = np.dot(ATAI[i],B[i])
        
    return Grad



bcdata = (['DIRICHLET', 0 ], ['DIRICHLET', 1 ],
          ['DIRICHLET', 2], ['DIRICHLET', 1])

print(least_square(mesh_obj,bcdata))

f = mesh_obj.number_of_elements
#%% Création de la fonction analytique 

def analytique(f,mesh_obj):
    
    Grad = np.zeros((f,2))
    coordonnees_elements_x = []
    coordonnees_elements_y = []
    for i in range(f):
        x_e, y_e = centre_element_2D(mesh_obj, i)
        coordonnees_elements_x.append(x_e)
        coordonnees_elements_y.append(y_e)  
        Grad[i][0] =  10*np.cos(x_e)
        Grad[i][1] = -100*np.sin(y_e)
    return Grad


def surface_cellule(noeuds, mesh_obj):
    n = len(noeuds)
    surface = 0
    points = []
    
    # Récupérer les coordonnées (x, y) des noeuds associés à la cellule
    for i in range(n):
        x, y = mesh_obj.get_node_to_xycoord(noeuds[i])  # Utiliser noeuds[i] pour les bons indices
        points.append((x, y))
        
    # Calcul de la surface avec la formule du déterminant (shoelace)
    for i in range(n):
        x1, y1 = points[i]
        x2, y2 = points[(i + 1) % n]  # Le sommet suivant, en bouclant sur le premier point
        surface += x1 * y2 - x2 * y1
    
    return abs(surface) / 2


def erreur_L1(sol_num, sol_anal, mesh_obj):
    erreur_x = 0
    erreur_y = 0
    ecart_total = 0
    surface_total = 0
    
    for i in range(len(sol_num)):
        # Récupération des nœuds associés à l'élément i
        start = mesh_obj.get_element_to_nodes_start(i)
        fin = mesh_obj.get_element_to_nodes_start(i + 1)
        noeuds_i_elements = mesh_obj.element_to_nodes[start:fin]
        
        # Calcul de la surface de la cellule
        taille_cellule = surface_cellule(noeuds_i_elements, mesh_obj)
        
        # Calcul des écarts pondérés par la taille de la cellule
        ecart_x = abs(sol_num[i][0] - sol_anal[i][0]) * taille_cellule
        ecart_y = abs(sol_num[i][1] - sol_anal[i][1]) * taille_cellule
        
        surface_total += taille_cellule
        erreur_x += ecart_x
        erreur_y += ecart_y
        ecart_total += ecart_x + ecart_y
    
    # Optionnel : affichage pour vérifier les calculs
    print(f"Surface totale: {surface_total}")
    
    return erreur_x, erreur_y, ecart_total


def erreur_infinie(sol_num, sol_anal, mesh_obj):
    max_erreur_x = 0
    max_erreur_y = 0
    
    for i in range(len(sol_num)):
        # Calcul des écarts absolus pour chaque composante (x et y)
        ecart_x = abs(sol_num[i][0] - sol_anal[i][0])
        ecart_y = abs(sol_num[i][1] - sol_anal[i][1])
        
        # Mise à jour des erreurs maximales
        max_erreur_x = max(max_erreur_x, ecart_x)
        max_erreur_y = max(max_erreur_y, ecart_y)
    
    # Calcul de la norme infinie comme le maximum entre les deux composantes
    norme_infinie = max(max_erreur_x, max_erreur_y)
    
    return max_erreur_x, max_erreur_y, norme_infinie



def OrdreConvergeance(x, y):
    dx = np.diff(x)
    dy = np.diff(y)
    slope = dy / dx
    return slope

# Création des points de difference  

a1= erreur_infinie(least_square(mesh_obj,bcdata),analytique(f,mesh_obj),mesh_obj)
h1 =1/f 
mesh_parameters2 = {'mesh_type': 'TRI',
                   'lc': 9.9
                   }
mesh_obj1= mesher.rectangle([0.0, 10.0, 0.0, 10.0], mesh_parameters2)
conec = MeshConnectivity(mesh_obj1)
conec.compute_connectivity()
#plotter.plot_mesh(mesh_obj1)
coordonnees_elements_x = []
coordonnees_elements_y = []
for i in range(f):
    x_e, y_e = centre_element_2D(mesh_obj, i)
    coordonnees_elements_x.append(x_e)
    coordonnees_elements_y.append(y_e)

calcul = least_square(mesh_obj,bcdata)
normalien= analytique(f,mesh_obj)

f2 = mesh_obj1.number_of_elements
a2 = erreur_infinie(least_square(mesh_obj1,bcdata),analytique(f2,mesh_obj1),mesh_obj1)
f2 = mesh_obj1.number_of_elements
h2 = 1/f2
x1,y1,t1 = a1
x2,y2,t2 = a2

X= [x1,x2]
Y = [y1,y2]
H= [h1,h2]
T = [t1,t2]

plt.figure(2)
plt.loglog(H, X,'-o', label="Erreur X")
plt.loglog(H, Y,'-o', label="Erreur Y")
plt.loglog(H, T,'-o', label="Erreur T")
plt.legend()
plt.xlabel("h")
plt.ylabel("Erreur(h)")
plt.legend()
plt.grid(True)
plt.title("Convergence de l'erreur ")
plt.show()

#Ordre de convergeance
B=str(max(abs(OrdreConvergeance(np.log(H),np.log(X)))))
print("La convergeance de l'erreur pour les fonctions complexes est de :"+ B)
C =str(max(abs(OrdreConvergeance(np.log(H),np.log(Y)))))
print("La convergeance de l'erreur pour les fonctions complexes est de :"+ C)
D=str(max(abs(OrdreConvergeance(np.log(H),np.log(T)))))
print("La convergeance de l'erreur pour les fonctions complexes est de :"+ D)


def erreur_Linf(sol_num, sol_anal):
    return np.max(np.abs(sol_num - sol_anal))
